{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\nvar helpers = require('@turf/helpers');\r\n\r\n/**\r\n * Callback for coordEach\r\n *\r\n * @callback coordEachCallback\r\n * @param {Array<number>} currentCoord The current coordinate being processed.\r\n * @param {number} coordIndex The current index of the coordinate being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n */\r\n\r\n/**\r\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name coordEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\r\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=currentCoord\r\n *   //=coordIndex\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n * });\r\n */\r\nfunction coordEach(geojson, callback, excludeWrapCoord) {\r\n  // Handles null Geometry -- Skips this GeoJSON\r\n  if (geojson === null) return;\r\n  var j,\r\n    k,\r\n    l,\r\n    geometry,\r\n    stopG,\r\n    coords,\r\n    geometryMaybeCollection,\r\n    wrapShrink = 0,\r\n    coordIndex = 0,\r\n    isGeometryCollection,\r\n    type = geojson.type,\r\n    isFeatureCollection = type === \"FeatureCollection\",\r\n    isFeature = type === \"Feature\",\r\n    stop = isFeatureCollection ? geojson.features.length : 1;\r\n\r\n  // This logic may look a little weird. The reason why it is that way\r\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\r\n  // of objects at its root: FeatureCollection, Features, Geometries.\r\n  // This function has the responsibility of handling all of them, and that\r\n  // means that some of the `for` loops you see below actually just don't apply\r\n  // to certain inputs. For instance, if you give this just a\r\n  // Point geometry, then both loops are short-circuited and all we do\r\n  // is gradually rename the input until it's called 'geometry'.\r\n  //\r\n  // This also aims to allocate as few resources as possible: just a\r\n  // few numbers and booleans, rather than any temporary arrays as would\r\n  // be required with the normalization approach.\r\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\r\n    geometryMaybeCollection = isFeatureCollection\r\n      ? geojson.features[featureIndex].geometry\r\n      : isFeature\r\n      ? geojson.geometry\r\n      : geojson;\r\n    isGeometryCollection = geometryMaybeCollection\r\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\r\n      : false;\r\n    stopG = isGeometryCollection\r\n      ? geometryMaybeCollection.geometries.length\r\n      : 1;\r\n\r\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\r\n      var multiFeatureIndex = 0;\r\n      var geometryIndex = 0;\r\n      geometry = isGeometryCollection\r\n        ? geometryMaybeCollection.geometries[geomIndex]\r\n        : geometryMaybeCollection;\r\n\r\n      // Handles null Geometry -- Skips this geometry\r\n      if (geometry === null) continue;\r\n      coords = geometry.coordinates;\r\n      var geomType = geometry.type;\r\n\r\n      wrapShrink =\r\n        excludeWrapCoord &&\r\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\r\n          ? 1\r\n          : 0;\r\n\r\n      switch (geomType) {\r\n        case null:\r\n          break;\r\n        case \"Point\":\r\n          if (\r\n            callback(\r\n              coords,\r\n              coordIndex,\r\n              featureIndex,\r\n              multiFeatureIndex,\r\n              geometryIndex\r\n            ) === false\r\n          )\r\n            return false;\r\n          coordIndex++;\r\n          multiFeatureIndex++;\r\n          break;\r\n        case \"LineString\":\r\n        case \"MultiPoint\":\r\n          for (j = 0; j < coords.length; j++) {\r\n            if (\r\n              callback(\r\n                coords[j],\r\n                coordIndex,\r\n                featureIndex,\r\n                multiFeatureIndex,\r\n                geometryIndex\r\n              ) === false\r\n            )\r\n              return false;\r\n            coordIndex++;\r\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\r\n          }\r\n          if (geomType === \"LineString\") multiFeatureIndex++;\r\n          break;\r\n        case \"Polygon\":\r\n        case \"MultiLineString\":\r\n          for (j = 0; j < coords.length; j++) {\r\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\r\n              if (\r\n                callback(\r\n                  coords[j][k],\r\n                  coordIndex,\r\n                  featureIndex,\r\n                  multiFeatureIndex,\r\n                  geometryIndex\r\n                ) === false\r\n              )\r\n                return false;\r\n              coordIndex++;\r\n            }\r\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\r\n            if (geomType === \"Polygon\") geometryIndex++;\r\n          }\r\n          if (geomType === \"Polygon\") multiFeatureIndex++;\r\n          break;\r\n        case \"MultiPolygon\":\r\n          for (j = 0; j < coords.length; j++) {\r\n            geometryIndex = 0;\r\n            for (k = 0; k < coords[j].length; k++) {\r\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\r\n                if (\r\n                  callback(\r\n                    coords[j][k][l],\r\n                    coordIndex,\r\n                    featureIndex,\r\n                    multiFeatureIndex,\r\n                    geometryIndex\r\n                  ) === false\r\n                )\r\n                  return false;\r\n                coordIndex++;\r\n              }\r\n              geometryIndex++;\r\n            }\r\n            multiFeatureIndex++;\r\n          }\r\n          break;\r\n        case \"GeometryCollection\":\r\n          for (j = 0; j < geometry.geometries.length; j++)\r\n            if (\r\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\r\n              false\r\n            )\r\n              return false;\r\n          break;\r\n        default:\r\n          throw new Error(\"Unknown Geometry Type\");\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Callback for coordReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback coordReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Array<number>} currentCoord The current coordinate being processed.\r\n * @param {number} coordIndex The current index of the coordinate being processed.\r\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n */\r\n\r\n/**\r\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\r\n *\r\n * @name coordReduce\r\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=previousValue\r\n *   //=currentCoord\r\n *   //=coordIndex\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   return currentCoord;\r\n * });\r\n */\r\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\r\n  var previousValue = initialValue;\r\n  coordEach(\r\n    geojson,\r\n    function (\r\n      currentCoord,\r\n      coordIndex,\r\n      featureIndex,\r\n      multiFeatureIndex,\r\n      geometryIndex\r\n    ) {\r\n      if (coordIndex === 0 && initialValue === undefined)\r\n        previousValue = currentCoord;\r\n      else\r\n        previousValue = callback(\r\n          previousValue,\r\n          currentCoord,\r\n          coordIndex,\r\n          featureIndex,\r\n          multiFeatureIndex,\r\n          geometryIndex\r\n        );\r\n    },\r\n    excludeWrapCoord\r\n  );\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for propEach\r\n *\r\n * @callback propEachCallback\r\n * @param {Object} currentProperties The current Properties being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name propEach\r\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.propEach(features, function (currentProperties, featureIndex) {\r\n *   //=currentProperties\r\n *   //=featureIndex\r\n * });\r\n */\r\nfunction propEach(geojson, callback) {\r\n  var i;\r\n  switch (geojson.type) {\r\n    case \"FeatureCollection\":\r\n      for (i = 0; i < geojson.features.length; i++) {\r\n        if (callback(geojson.features[i].properties, i) === false) break;\r\n      }\r\n      break;\r\n    case \"Feature\":\r\n      callback(geojson.properties, 0);\r\n      break;\r\n  }\r\n}\r\n\r\n/**\r\n * Callback for propReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback propReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {*} currentProperties The current Properties being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Reduce properties in any GeoJSON object into a single value,\r\n * similar to how Array.reduce works. However, in this case we lazily run\r\n * the reduction, so an array of all properties is unnecessary.\r\n *\r\n * @name propReduce\r\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\r\n *   //=previousValue\r\n *   //=currentProperties\r\n *   //=featureIndex\r\n *   return currentProperties\r\n * });\r\n */\r\nfunction propReduce(geojson, callback, initialValue) {\r\n  var previousValue = initialValue;\r\n  propEach(geojson, function (currentProperties, featureIndex) {\r\n    if (featureIndex === 0 && initialValue === undefined)\r\n      previousValue = currentProperties;\r\n    else\r\n      previousValue = callback(previousValue, currentProperties, featureIndex);\r\n  });\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for featureEach\r\n *\r\n * @callback featureEachCallback\r\n * @param {Feature<any>} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Iterate over features in any GeoJSON object, similar to\r\n * Array.forEach.\r\n *\r\n * @name featureEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {foo: 'bar'}),\r\n *   turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.featureEach(features, function (currentFeature, featureIndex) {\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n * });\r\n */\r\nfunction featureEach(geojson, callback) {\r\n  if (geojson.type === \"Feature\") {\r\n    callback(geojson, 0);\r\n  } else if (geojson.type === \"FeatureCollection\") {\r\n    for (var i = 0; i < geojson.features.length; i++) {\r\n      if (callback(geojson.features[i], i) === false) break;\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Callback for featureReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback featureReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n */\r\n\r\n/**\r\n * Reduce features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name featureReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\r\n *   turf.point([36, 53], {\"hello\": \"world\"})\r\n * ]);\r\n *\r\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\r\n *   //=previousValue\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   return currentFeature\r\n * });\r\n */\r\nfunction featureReduce(geojson, callback, initialValue) {\r\n  var previousValue = initialValue;\r\n  featureEach(geojson, function (currentFeature, featureIndex) {\r\n    if (featureIndex === 0 && initialValue === undefined)\r\n      previousValue = currentFeature;\r\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\r\n  });\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Get all coordinates from any GeoJSON object.\r\n *\r\n * @name coordAll\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @returns {Array<Array<number>>} coordinate position array\r\n * @example\r\n * var features = turf.featureCollection([\r\n *   turf.point([26, 37], {foo: 'bar'}),\r\n *   turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * var coords = turf.coordAll(features);\r\n * //= [[26, 37], [36, 53]]\r\n */\r\nfunction coordAll(geojson) {\r\n  var coords = [];\r\n  coordEach(geojson, function (coord) {\r\n    coords.push(coord);\r\n  });\r\n  return coords;\r\n}\r\n\r\n/**\r\n * Callback for geomEach\r\n *\r\n * @callback geomEachCallback\r\n * @param {Geometry} currentGeometry The current Geometry being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {Object} featureProperties The current Feature Properties being processed.\r\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\r\n * @param {number|string} featureId The current Feature Id being processed.\r\n */\r\n\r\n/**\r\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\r\n *\r\n * @name geomEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\r\n * @returns {void}\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\r\n *   //=currentGeometry\r\n *   //=featureIndex\r\n *   //=featureProperties\r\n *   //=featureBBox\r\n *   //=featureId\r\n * });\r\n */\r\nfunction geomEach(geojson, callback) {\r\n  var i,\r\n    j,\r\n    g,\r\n    geometry,\r\n    stopG,\r\n    geometryMaybeCollection,\r\n    isGeometryCollection,\r\n    featureProperties,\r\n    featureBBox,\r\n    featureId,\r\n    featureIndex = 0,\r\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\r\n    isFeature = geojson.type === \"Feature\",\r\n    stop = isFeatureCollection ? geojson.features.length : 1;\r\n\r\n  // This logic may look a little weird. The reason why it is that way\r\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\r\n  // of objects at its root: FeatureCollection, Features, Geometries.\r\n  // This function has the responsibility of handling all of them, and that\r\n  // means that some of the `for` loops you see below actually just don't apply\r\n  // to certain inputs. For instance, if you give this just a\r\n  // Point geometry, then both loops are short-circuited and all we do\r\n  // is gradually rename the input until it's called 'geometry'.\r\n  //\r\n  // This also aims to allocate as few resources as possible: just a\r\n  // few numbers and booleans, rather than any temporary arrays as would\r\n  // be required with the normalization approach.\r\n  for (i = 0; i < stop; i++) {\r\n    geometryMaybeCollection = isFeatureCollection\r\n      ? geojson.features[i].geometry\r\n      : isFeature\r\n      ? geojson.geometry\r\n      : geojson;\r\n    featureProperties = isFeatureCollection\r\n      ? geojson.features[i].properties\r\n      : isFeature\r\n      ? geojson.properties\r\n      : {};\r\n    featureBBox = isFeatureCollection\r\n      ? geojson.features[i].bbox\r\n      : isFeature\r\n      ? geojson.bbox\r\n      : undefined;\r\n    featureId = isFeatureCollection\r\n      ? geojson.features[i].id\r\n      : isFeature\r\n      ? geojson.id\r\n      : undefined;\r\n    isGeometryCollection = geometryMaybeCollection\r\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\r\n      : false;\r\n    stopG = isGeometryCollection\r\n      ? geometryMaybeCollection.geometries.length\r\n      : 1;\r\n\r\n    for (g = 0; g < stopG; g++) {\r\n      geometry = isGeometryCollection\r\n        ? geometryMaybeCollection.geometries[g]\r\n        : geometryMaybeCollection;\r\n\r\n      // Handle null Geometry\r\n      if (geometry === null) {\r\n        if (\r\n          callback(\r\n            null,\r\n            featureIndex,\r\n            featureProperties,\r\n            featureBBox,\r\n            featureId\r\n          ) === false\r\n        )\r\n          return false;\r\n        continue;\r\n      }\r\n      switch (geometry.type) {\r\n        case \"Point\":\r\n        case \"LineString\":\r\n        case \"MultiPoint\":\r\n        case \"Polygon\":\r\n        case \"MultiLineString\":\r\n        case \"MultiPolygon\": {\r\n          if (\r\n            callback(\r\n              geometry,\r\n              featureIndex,\r\n              featureProperties,\r\n              featureBBox,\r\n              featureId\r\n            ) === false\r\n          )\r\n            return false;\r\n          break;\r\n        }\r\n        case \"GeometryCollection\": {\r\n          for (j = 0; j < geometry.geometries.length; j++) {\r\n            if (\r\n              callback(\r\n                geometry.geometries[j],\r\n                featureIndex,\r\n                featureProperties,\r\n                featureBBox,\r\n                featureId\r\n              ) === false\r\n            )\r\n              return false;\r\n          }\r\n          break;\r\n        }\r\n        default:\r\n          throw new Error(\"Unknown Geometry Type\");\r\n      }\r\n    }\r\n    // Only increase `featureIndex` per each feature\r\n    featureIndex++;\r\n  }\r\n}\r\n\r\n/**\r\n * Callback for geomReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback geomReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Geometry} currentGeometry The current Geometry being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {Object} featureProperties The current Feature Properties being processed.\r\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\r\n * @param {number|string} featureId The current Feature Id being processed.\r\n */\r\n\r\n/**\r\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name geomReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.point([36, 53], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\r\n *   //=previousValue\r\n *   //=currentGeometry\r\n *   //=featureIndex\r\n *   //=featureProperties\r\n *   //=featureBBox\r\n *   //=featureId\r\n *   return currentGeometry\r\n * });\r\n */\r\nfunction geomReduce(geojson, callback, initialValue) {\r\n  var previousValue = initialValue;\r\n  geomEach(\r\n    geojson,\r\n    function (\r\n      currentGeometry,\r\n      featureIndex,\r\n      featureProperties,\r\n      featureBBox,\r\n      featureId\r\n    ) {\r\n      if (featureIndex === 0 && initialValue === undefined)\r\n        previousValue = currentGeometry;\r\n      else\r\n        previousValue = callback(\r\n          previousValue,\r\n          currentGeometry,\r\n          featureIndex,\r\n          featureProperties,\r\n          featureBBox,\r\n          featureId\r\n        );\r\n    }\r\n  );\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for flattenEach\r\n *\r\n * @callback flattenEachCallback\r\n * @param {Feature} currentFeature The current flattened feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n */\r\n\r\n/**\r\n * Iterate over flattened features in any GeoJSON object, similar to\r\n * Array.forEach.\r\n *\r\n * @name flattenEach\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n * });\r\n */\r\nfunction flattenEach(geojson, callback) {\r\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\r\n    // Callback for single geometry\r\n    var type = geometry === null ? null : geometry.type;\r\n    switch (type) {\r\n      case null:\r\n      case \"Point\":\r\n      case \"LineString\":\r\n      case \"Polygon\":\r\n        if (\r\n          callback(\r\n            helpers.feature(geometry, properties, { bbox: bbox, id: id }),\r\n            featureIndex,\r\n            0\r\n          ) === false\r\n        )\r\n          return false;\r\n        return;\r\n    }\r\n\r\n    var geomType;\r\n\r\n    // Callback for multi-geometry\r\n    switch (type) {\r\n      case \"MultiPoint\":\r\n        geomType = \"Point\";\r\n        break;\r\n      case \"MultiLineString\":\r\n        geomType = \"LineString\";\r\n        break;\r\n      case \"MultiPolygon\":\r\n        geomType = \"Polygon\";\r\n        break;\r\n    }\r\n\r\n    for (\r\n      var multiFeatureIndex = 0;\r\n      multiFeatureIndex < geometry.coordinates.length;\r\n      multiFeatureIndex++\r\n    ) {\r\n      var coordinate = geometry.coordinates[multiFeatureIndex];\r\n      var geom = {\r\n        type: geomType,\r\n        coordinates: coordinate,\r\n      };\r\n      if (\r\n        callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) ===\r\n        false\r\n      )\r\n        return false;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Callback for flattenReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback flattenReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature} currentFeature The current Feature being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n */\r\n\r\n/**\r\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name flattenReduce\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\r\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var features = turf.featureCollection([\r\n *     turf.point([26, 37], {foo: 'bar'}),\r\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\r\n * ]);\r\n *\r\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\r\n *   //=previousValue\r\n *   //=currentFeature\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   return currentFeature\r\n * });\r\n */\r\nfunction flattenReduce(geojson, callback, initialValue) {\r\n  var previousValue = initialValue;\r\n  flattenEach(\r\n    geojson,\r\n    function (currentFeature, featureIndex, multiFeatureIndex) {\r\n      if (\r\n        featureIndex === 0 &&\r\n        multiFeatureIndex === 0 &&\r\n        initialValue === undefined\r\n      )\r\n        previousValue = currentFeature;\r\n      else\r\n        previousValue = callback(\r\n          previousValue,\r\n          currentFeature,\r\n          featureIndex,\r\n          multiFeatureIndex\r\n        );\r\n    }\r\n  );\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for segmentEach\r\n *\r\n * @callback segmentEachCallback\r\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n * @param {number} segmentIndex The current index of the Segment being processed.\r\n * @returns {void}\r\n */\r\n\r\n/**\r\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\r\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\r\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\r\n * @returns {void}\r\n * @example\r\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\r\n *\r\n * // Iterate over GeoJSON by 2-vertex segments\r\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\r\n *   //=currentSegment\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   //=segmentIndex\r\n * });\r\n *\r\n * // Calculate the total number of segments\r\n * var total = 0;\r\n * turf.segmentEach(polygon, function () {\r\n *     total++;\r\n * });\r\n */\r\nfunction segmentEach(geojson, callback) {\r\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\r\n    var segmentIndex = 0;\r\n\r\n    // Exclude null Geometries\r\n    if (!feature.geometry) return;\r\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n    var type = feature.geometry.type;\r\n    if (type === \"Point\" || type === \"MultiPoint\") return;\r\n\r\n    // Generate 2-vertex line segments\r\n    var previousCoords;\r\n    var previousFeatureIndex = 0;\r\n    var previousMultiIndex = 0;\r\n    var prevGeomIndex = 0;\r\n    if (\r\n      coordEach(\r\n        feature,\r\n        function (\r\n          currentCoord,\r\n          coordIndex,\r\n          featureIndexCoord,\r\n          multiPartIndexCoord,\r\n          geometryIndex\r\n        ) {\r\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\r\n          if (\r\n            previousCoords === undefined ||\r\n            featureIndex > previousFeatureIndex ||\r\n            multiPartIndexCoord > previousMultiIndex ||\r\n            geometryIndex > prevGeomIndex\r\n          ) {\r\n            previousCoords = currentCoord;\r\n            previousFeatureIndex = featureIndex;\r\n            previousMultiIndex = multiPartIndexCoord;\r\n            prevGeomIndex = geometryIndex;\r\n            segmentIndex = 0;\r\n            return;\r\n          }\r\n          var currentSegment = helpers.lineString(\r\n            [previousCoords, currentCoord],\r\n            feature.properties\r\n          );\r\n          if (\r\n            callback(\r\n              currentSegment,\r\n              featureIndex,\r\n              multiFeatureIndex,\r\n              geometryIndex,\r\n              segmentIndex\r\n            ) === false\r\n          )\r\n            return false;\r\n          segmentIndex++;\r\n          previousCoords = currentCoord;\r\n        }\r\n      ) === false\r\n    )\r\n      return false;\r\n  });\r\n}\r\n\r\n/**\r\n * Callback for segmentReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback segmentReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed.\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\r\n * @param {number} geometryIndex The current index of the Geometry being processed.\r\n * @param {number} segmentIndex The current index of the Segment being processed.\r\n */\r\n\r\n/**\r\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\r\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\r\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {void}\r\n * @example\r\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\r\n *\r\n * // Iterate over GeoJSON by 2-vertex segments\r\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\r\n *   //= previousSegment\r\n *   //= currentSegment\r\n *   //= featureIndex\r\n *   //= multiFeatureIndex\r\n *   //= geometryIndex\r\n *   //= segmentIndex\r\n *   return currentSegment\r\n * });\r\n *\r\n * // Calculate the total number of segments\r\n * var initialValue = 0\r\n * var total = turf.segmentReduce(polygon, function (previousValue) {\r\n *     previousValue++;\r\n *     return previousValue;\r\n * }, initialValue);\r\n */\r\nfunction segmentReduce(geojson, callback, initialValue) {\r\n  var previousValue = initialValue;\r\n  var started = false;\r\n  segmentEach(\r\n    geojson,\r\n    function (\r\n      currentSegment,\r\n      featureIndex,\r\n      multiFeatureIndex,\r\n      geometryIndex,\r\n      segmentIndex\r\n    ) {\r\n      if (started === false && initialValue === undefined)\r\n        previousValue = currentSegment;\r\n      else\r\n        previousValue = callback(\r\n          previousValue,\r\n          currentSegment,\r\n          featureIndex,\r\n          multiFeatureIndex,\r\n          geometryIndex,\r\n          segmentIndex\r\n        );\r\n      started = true;\r\n    }\r\n  );\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Callback for lineEach\r\n *\r\n * @callback lineEachCallback\r\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\r\n * @param {number} featureIndex The current index of the Feature being processed\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\r\n * @param {number} geometryIndex The current index of the Geometry being processed\r\n */\r\n\r\n/**\r\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\r\n * similar to Array.forEach.\r\n *\r\n * @name lineEach\r\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\r\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *   [[26, 37], [35, 45]],\r\n *   [[36, 53], [38, 50], [41, 55]]\r\n * ]);\r\n *\r\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=currentLine\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n * });\r\n */\r\nfunction lineEach(geojson, callback) {\r\n  // validation\r\n  if (!geojson) throw new Error(\"geojson is required\");\r\n\r\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\r\n    if (feature.geometry === null) return;\r\n    var type = feature.geometry.type;\r\n    var coords = feature.geometry.coordinates;\r\n    switch (type) {\r\n      case \"LineString\":\r\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\r\n          return false;\r\n        break;\r\n      case \"Polygon\":\r\n        for (\r\n          var geometryIndex = 0;\r\n          geometryIndex < coords.length;\r\n          geometryIndex++\r\n        ) {\r\n          if (\r\n            callback(\r\n              helpers.lineString(coords[geometryIndex], feature.properties),\r\n              featureIndex,\r\n              multiFeatureIndex,\r\n              geometryIndex\r\n            ) === false\r\n          )\r\n            return false;\r\n        }\r\n        break;\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Callback for lineReduce\r\n *\r\n * The first time the callback function is called, the values provided as arguments depend\r\n * on whether the reduce method has an initialValue argument.\r\n *\r\n * If an initialValue is provided to the reduce method:\r\n *  - The previousValue argument is initialValue.\r\n *  - The currentValue argument is the value of the first element present in the array.\r\n *\r\n * If an initialValue is not provided:\r\n *  - The previousValue argument is the value of the first element present in the array.\r\n *  - The currentValue argument is the value of the second element present in the array.\r\n *\r\n * @callback lineReduceCallback\r\n * @param {*} previousValue The accumulated value previously returned in the last invocation\r\n * of the callback, or initialValue, if supplied.\r\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\r\n * @param {number} featureIndex The current index of the Feature being processed\r\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\r\n * @param {number} geometryIndex The current index of the Geometry being processed\r\n */\r\n\r\n/**\r\n * Reduce features in any GeoJSON object, similar to Array.reduce().\r\n *\r\n * @name lineReduce\r\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\r\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\r\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\r\n * @returns {*} The value that results from the reduction.\r\n * @example\r\n * var multiPoly = turf.multiPolygon([\r\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\r\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\r\n * ]);\r\n *\r\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n *   //=previousValue\r\n *   //=currentLine\r\n *   //=featureIndex\r\n *   //=multiFeatureIndex\r\n *   //=geometryIndex\r\n *   return currentLine\r\n * });\r\n */\r\nfunction lineReduce(geojson, callback, initialValue) {\r\n  var previousValue = initialValue;\r\n  lineEach(\r\n    geojson,\r\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\r\n      if (featureIndex === 0 && initialValue === undefined)\r\n        previousValue = currentLine;\r\n      else\r\n        previousValue = callback(\r\n          previousValue,\r\n          currentLine,\r\n          featureIndex,\r\n          multiFeatureIndex,\r\n          geometryIndex\r\n        );\r\n    }\r\n  );\r\n  return previousValue;\r\n}\r\n\r\n/**\r\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\r\n *\r\n * Negative indexes are permitted.\r\n * Point & MultiPoint will always return null.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.featureIndex=0] Feature Index\r\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\r\n * @param {number} [options.geometryIndex=0] Geometry Index\r\n * @param {number} [options.segmentIndex=0] Segment Index\r\n * @param {Object} [options.properties={}] Translate Properties to output LineString\r\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\r\n * @param {number|string} [options.id={}] Translate Id to output LineString\r\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *     [[10, 10], [50, 30], [30, 40]],\r\n *     [[-10, -10], [-50, -30], [-30, -40]]\r\n * ]);\r\n *\r\n * // First Segment (defaults are 0)\r\n * turf.findSegment(multiLine);\r\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\r\n *\r\n * // First Segment of 2nd Multi Feature\r\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\r\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\r\n *\r\n * // Last Segment of Last Multi Feature\r\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\r\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\r\n */\r\nfunction findSegment(geojson, options) {\r\n  // Optional Parameters\r\n  options = options || {};\r\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\r\n  var featureIndex = options.featureIndex || 0;\r\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\r\n  var geometryIndex = options.geometryIndex || 0;\r\n  var segmentIndex = options.segmentIndex || 0;\r\n\r\n  // Find FeatureIndex\r\n  var properties = options.properties;\r\n  var geometry;\r\n\r\n  switch (geojson.type) {\r\n    case \"FeatureCollection\":\r\n      if (featureIndex < 0)\r\n        featureIndex = geojson.features.length + featureIndex;\r\n      properties = properties || geojson.features[featureIndex].properties;\r\n      geometry = geojson.features[featureIndex].geometry;\r\n      break;\r\n    case \"Feature\":\r\n      properties = properties || geojson.properties;\r\n      geometry = geojson.geometry;\r\n      break;\r\n    case \"Point\":\r\n    case \"MultiPoint\":\r\n      return null;\r\n    case \"LineString\":\r\n    case \"Polygon\":\r\n    case \"MultiLineString\":\r\n    case \"MultiPolygon\":\r\n      geometry = geojson;\r\n      break;\r\n    default:\r\n      throw new Error(\"geojson is invalid\");\r\n  }\r\n\r\n  // Find SegmentIndex\r\n  if (geometry === null) return null;\r\n  var coords = geometry.coordinates;\r\n  switch (geometry.type) {\r\n    case \"Point\":\r\n    case \"MultiPoint\":\r\n      return null;\r\n    case \"LineString\":\r\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\r\n      return helpers.lineString(\r\n        [coords[segmentIndex], coords[segmentIndex + 1]],\r\n        properties,\r\n        options\r\n      );\r\n    case \"Polygon\":\r\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\r\n      if (segmentIndex < 0)\r\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\r\n      return helpers.lineString(\r\n        [\r\n          coords[geometryIndex][segmentIndex],\r\n          coords[geometryIndex][segmentIndex + 1],\r\n        ],\r\n        properties,\r\n        options\r\n      );\r\n    case \"MultiLineString\":\r\n      if (multiFeatureIndex < 0)\r\n        multiFeatureIndex = coords.length + multiFeatureIndex;\r\n      if (segmentIndex < 0)\r\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\r\n      return helpers.lineString(\r\n        [\r\n          coords[multiFeatureIndex][segmentIndex],\r\n          coords[multiFeatureIndex][segmentIndex + 1],\r\n        ],\r\n        properties,\r\n        options\r\n      );\r\n    case \"MultiPolygon\":\r\n      if (multiFeatureIndex < 0)\r\n        multiFeatureIndex = coords.length + multiFeatureIndex;\r\n      if (geometryIndex < 0)\r\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\r\n      if (segmentIndex < 0)\r\n        segmentIndex =\r\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\r\n      return helpers.lineString(\r\n        [\r\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\r\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\r\n        ],\r\n        properties,\r\n        options\r\n      );\r\n  }\r\n  throw new Error(\"geojson is invalid\");\r\n}\r\n\r\n/**\r\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\r\n *\r\n * Negative indexes are permitted.\r\n *\r\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {number} [options.featureIndex=0] Feature Index\r\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\r\n * @param {number} [options.geometryIndex=0] Geometry Index\r\n * @param {number} [options.coordIndex=0] Coord Index\r\n * @param {Object} [options.properties={}] Translate Properties to output Point\r\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\r\n * @param {number|string} [options.id={}] Translate Id to output Point\r\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\r\n * @example\r\n * var multiLine = turf.multiLineString([\r\n *     [[10, 10], [50, 30], [30, 40]],\r\n *     [[-10, -10], [-50, -30], [-30, -40]]\r\n * ]);\r\n *\r\n * // First Segment (defaults are 0)\r\n * turf.findPoint(multiLine);\r\n * // => Feature<Point<[10, 10]>>\r\n *\r\n * // First Segment of the 2nd Multi-Feature\r\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\r\n * // => Feature<Point<[-10, -10]>>\r\n *\r\n * // Last Segment of last Multi-Feature\r\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\r\n * // => Feature<Point<[-30, -40]>>\r\n */\r\nfunction findPoint(geojson, options) {\r\n  // Optional Parameters\r\n  options = options || {};\r\n  if (!helpers.isObject(options)) throw new Error(\"options is invalid\");\r\n  var featureIndex = options.featureIndex || 0;\r\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\r\n  var geometryIndex = options.geometryIndex || 0;\r\n  var coordIndex = options.coordIndex || 0;\r\n\r\n  // Find FeatureIndex\r\n  var properties = options.properties;\r\n  var geometry;\r\n\r\n  switch (geojson.type) {\r\n    case \"FeatureCollection\":\r\n      if (featureIndex < 0)\r\n        featureIndex = geojson.features.length + featureIndex;\r\n      properties = properties || geojson.features[featureIndex].properties;\r\n      geometry = geojson.features[featureIndex].geometry;\r\n      break;\r\n    case \"Feature\":\r\n      properties = properties || geojson.properties;\r\n      geometry = geojson.geometry;\r\n      break;\r\n    case \"Point\":\r\n    case \"MultiPoint\":\r\n      return null;\r\n    case \"LineString\":\r\n    case \"Polygon\":\r\n    case \"MultiLineString\":\r\n    case \"MultiPolygon\":\r\n      geometry = geojson;\r\n      break;\r\n    default:\r\n      throw new Error(\"geojson is invalid\");\r\n  }\r\n\r\n  // Find Coord Index\r\n  if (geometry === null) return null;\r\n  var coords = geometry.coordinates;\r\n  switch (geometry.type) {\r\n    case \"Point\":\r\n      return helpers.point(coords, properties, options);\r\n    case \"MultiPoint\":\r\n      if (multiFeatureIndex < 0)\r\n        multiFeatureIndex = coords.length + multiFeatureIndex;\r\n      return helpers.point(coords[multiFeatureIndex], properties, options);\r\n    case \"LineString\":\r\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\r\n      return helpers.point(coords[coordIndex], properties, options);\r\n    case \"Polygon\":\r\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\r\n      if (coordIndex < 0)\r\n        coordIndex = coords[geometryIndex].length + coordIndex;\r\n      return helpers.point(coords[geometryIndex][coordIndex], properties, options);\r\n    case \"MultiLineString\":\r\n      if (multiFeatureIndex < 0)\r\n        multiFeatureIndex = coords.length + multiFeatureIndex;\r\n      if (coordIndex < 0)\r\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\r\n      return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);\r\n    case \"MultiPolygon\":\r\n      if (multiFeatureIndex < 0)\r\n        multiFeatureIndex = coords.length + multiFeatureIndex;\r\n      if (geometryIndex < 0)\r\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\r\n      if (coordIndex < 0)\r\n        coordIndex =\r\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\r\n      return helpers.point(\r\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\r\n        properties,\r\n        options\r\n      );\r\n  }\r\n  throw new Error(\"geojson is invalid\");\r\n}\r\n\r\nexports.coordAll = coordAll;\r\nexports.coordEach = coordEach;\r\nexports.coordReduce = coordReduce;\r\nexports.featureEach = featureEach;\r\nexports.featureReduce = featureReduce;\r\nexports.findPoint = findPoint;\r\nexports.findSegment = findSegment;\r\nexports.flattenEach = flattenEach;\r\nexports.flattenReduce = flattenReduce;\r\nexports.geomEach = geomEach;\r\nexports.geomReduce = geomReduce;\r\nexports.lineEach = lineEach;\r\nexports.lineReduce = lineReduce;\r\nexports.propEach = propEach;\r\nexports.propReduce = propReduce;\r\nexports.segmentEach = segmentEach;\r\nexports.segmentReduce = segmentReduce;\r\n"]}