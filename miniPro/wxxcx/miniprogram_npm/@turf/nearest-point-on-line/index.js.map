{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nvar bearing_1 = __importDefault(require(\"@turf/bearing\"));\r\nvar distance_1 = __importDefault(require(\"@turf/distance\"));\r\nvar destination_1 = __importDefault(require(\"@turf/destination\"));\r\nvar line_intersect_1 = __importDefault(require(\"@turf/line-intersect\"));\r\nvar meta_1 = require(\"@turf/meta\");\r\nvar helpers_1 = require(\"@turf/helpers\");\r\nvar invariant_1 = require(\"@turf/invariant\");\r\n/**\r\n * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.\r\n *\r\n * @name nearestPointOnLine\r\n * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to\r\n * @param {Geometry|Feature<Point>|number[]} pt point to snap from\r\n * @param {Object} [options={}] Optional parameters\r\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\r\n * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.\r\n * @example\r\n * var line = turf.lineString([\r\n *     [-77.031669, 38.878605],\r\n *     [-77.029609, 38.881946],\r\n *     [-77.020339, 38.884084],\r\n *     [-77.025661, 38.885821],\r\n *     [-77.021884, 38.889563],\r\n *     [-77.019824, 38.892368]\r\n * ]);\r\n * var pt = turf.point([-77.037076, 38.884017]);\r\n *\r\n * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});\r\n *\r\n * //addToMap\r\n * var addToMap = [line, pt, snapped];\r\n * snapped.properties['marker-color'] = '#00f';\r\n */\r\nfunction nearestPointOnLine(lines, pt, options) {\r\n    if (options === void 0) { options = {}; }\r\n    var closestPt = helpers_1.point([Infinity, Infinity], {\r\n        dist: Infinity,\r\n    });\r\n    var length = 0.0;\r\n    meta_1.flattenEach(lines, function (line) {\r\n        var coords = invariant_1.getCoords(line);\r\n        for (var i = 0; i < coords.length - 1; i++) {\r\n            //start\r\n            var start = helpers_1.point(coords[i]);\r\n            start.properties.dist = distance_1.default(pt, start, options);\r\n            //stop\r\n            var stop_1 = helpers_1.point(coords[i + 1]);\r\n            stop_1.properties.dist = distance_1.default(pt, stop_1, options);\r\n            // sectionLength\r\n            var sectionLength = distance_1.default(start, stop_1, options);\r\n            //perpendicular\r\n            var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);\r\n            var direction = bearing_1.default(start, stop_1);\r\n            var perpendicularPt1 = destination_1.default(pt, heightDistance, direction + 90, options);\r\n            var perpendicularPt2 = destination_1.default(pt, heightDistance, direction - 90, options);\r\n            var intersect = line_intersect_1.default(helpers_1.lineString([\r\n                perpendicularPt1.geometry.coordinates,\r\n                perpendicularPt2.geometry.coordinates,\r\n            ]), helpers_1.lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));\r\n            var intersectPt = null;\r\n            if (intersect.features.length > 0) {\r\n                intersectPt = intersect.features[0];\r\n                intersectPt.properties.dist = distance_1.default(pt, intersectPt, options);\r\n                intersectPt.properties.location =\r\n                    length + distance_1.default(start, intersectPt, options);\r\n            }\r\n            if (start.properties.dist < closestPt.properties.dist) {\r\n                closestPt = start;\r\n                closestPt.properties.index = i;\r\n                closestPt.properties.location = length;\r\n            }\r\n            if (stop_1.properties.dist < closestPt.properties.dist) {\r\n                closestPt = stop_1;\r\n                closestPt.properties.index = i + 1;\r\n                closestPt.properties.location = length + sectionLength;\r\n            }\r\n            if (intersectPt &&\r\n                intersectPt.properties.dist < closestPt.properties.dist) {\r\n                closestPt = intersectPt;\r\n                closestPt.properties.index = i;\r\n            }\r\n            // update length\r\n            length += sectionLength;\r\n        }\r\n    });\r\n    return closestPt;\r\n}\r\nexports.default = nearestPointOnLine;\r\n"]}